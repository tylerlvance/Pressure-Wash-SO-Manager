# -*- coding: utf-8 -*-
from __future__ import annotations

from typing import Any, List, Optional
from dataclasses import dataclass

from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QLineEdit, QPushButton, QTableWidget,
    QTableWidgetItem, QAbstractItemView, QHeaderView, QCheckBox, QDoubleSpinBox,
    QMessageBox, QFrame, QLabel
)

@dataclass
class _CatRow:
    id: Optional[int]
    name: str
    description: str
    default_price_cents: int
    active: bool

def _to_dollars(cents: int) -> float:
    return float(cents or 0) / 100.0

def _to_cents(dollars: float) -> int:
    return int(round(float(dollars or 0.0) * 100))

# --- repo helpers (stay flexible with your Repo API) ---
def _repo_list(repo, *, include_inactive: bool = True) -> List[Any]:
    try:
        return repo.list_catalog(active_only=not include_inactive)
    except TypeError:
        return repo.list_catalog()

def _repo_create(repo, **kw) -> Any:
    for fn in ("create_catalog_item", "create_catalog", "add_catalog_item"):
        if hasattr(repo, fn):
            return getattr(repo, fn)(**kw)
    raise AttributeError("No repo method to create catalog items")

def _repo_update(repo, item_id: int, **kw) -> Any:
    for fn in ("update_catalog_item", "update_catalog"):
        if hasattr(repo, fn):
            return getattr(repo, fn)(item_id, **kw)
    raise AttributeError("No repo method to update catalog items")

def _repo_delete(repo, item_id: int) -> Any:
    for fn in ("delete_catalog_item", "delete_catalog"):
        if hasattr(repo, fn):
            return getattr(repo, fn)(item_id)
    raise AttributeError("No repo method to delete catalog items")


class CatalogManagerDialog(QDialog):
    """
    Modern Catalog Manager with inline editing.
    Columns: Name | Description | Default Rate | Active

    Edits:
      - Double-click or select+F2 to edit Name/Description
      - Spinbox for Default Rate
      - Checkbox for Active
    """
    def __init__(self, session_or_repo: Any, parent: QWidget | None = None):
        super().__init__(parent)
        self.setWindowTitle("Catalog Manager")
        self.setMinimumWidth(700)

        # Resolve repo
        self.repo = getattr(parent, "repo", session_or_repo)

        self._deleted_ids: set[int] = set()
        self._rows_cache: List[_CatRow] = []

        root = QVBoxLayout(self)

        # Top: search + actions
        top = QHBoxLayout()
        self.search = QLineEdit()
        self.search.setPlaceholderText("Search name or description")
        self.btn_add = QPushButton("Add")
        self.btn_dup = QPushButton("Duplicate")
        self.btn_del = QPushButton("Delete")
        top.addWidget(self.search, 1)
        top.addWidget(self.btn_add)
        top.addWidget(self.btn_dup)
        top.addWidget(self.btn_del)
        root.addLayout(top)

        # Divider
        sep = QFrame(); sep.setFrameShape(QFrame.HLine); sep.setFrameShadow(QFrame.Sunken)
        root.addWidget(sep)

        # Table
        self.tbl = QTableWidget(0, 4)
        self.tbl.setHorizontalHeaderLabels(["Name", "Description", "Default Rate", "Active"])
        hh = self.tbl.horizontalHeader()
        hh.setSectionResizeMode(0, QHeaderView.Stretch)
        hh.setSectionResizeMode(1, QHeaderView.Stretch)
        hh.setSectionResizeMode(2, QHeaderView.ResizeToContents)
        hh.setSectionResizeMode(3, QHeaderView.ResizeToContents)
        self.tbl.verticalHeader().setVisible(False)
        self.tbl.setAlternatingRowColors(True)
        self.tbl.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.tbl.setSelectionMode(QAbstractItemView.SingleSelection)

        # IMPORTANT: enable inline edits for items
        self.tbl.setEditTriggers(
            QAbstractItemView.DoubleClicked
            | QAbstractItemView.SelectedClicked
            | QAbstractItemView.EditKeyPressed
        )

        root.addWidget(self.tbl, 1)

        # Bottom: save/close
        btm = QHBoxLayout()
        btm.addStretch(1)
        self.btn_save = QPushButton("Save")
        self.btn_close = QPushButton("Close")
        btm.addWidget(self.btn_save)
        btm.addWidget(self.btn_close)
        root.addLayout(btm)

        # Style
        self.setStyleSheet("""
            QDialog { background: #fafafa; }
            QLineEdit { padding: 6px; }
            QPushButton { padding: 6px 10px; }
            QTableWidget { gridline-color: #dddddd; }
        """)

        # Signals
        self.btn_add.clicked.connect(self._add_row)
        self.btn_dup.clicked.connect(self._duplicate_row)
        self.btn_del.clicked.connect(self._delete_row)
        self.btn_save.clicked.connect(self._save_all)
        self.btn_close.clicked.connect(self.accept)
        self.search.textChanged.connect(self._apply_filter)

        # Load rows
        self._load()

        # Friendly hint
        self.tbl.setToolTip("Double-click a cell in Name or Description to edit. Press F2 to edit the selected cell.")

    # ---------- load/build ----------
    def _load(self):
        self.tbl.setRowCount(0)
        self._rows_cache.clear()
        try:
            rows = _repo_list(self.repo, include_inactive=True)
        except Exception as e:
            QMessageBox.warning(self, "Catalog", f"Could not load catalog:\n{e}")
            rows = []

        for c in rows:
            self._rows_cache.append(_CatRow(
                id=getattr(c, "id", None),
                name=getattr(c, "name", "") or "",
                description=getattr(c, "description", "") or "",
                default_price_cents=int(getattr(c, "default_price_cents", 0) or 0),
                active=bool(getattr(c, "active", True)),
            ))

        for r in self._rows_cache:
            self._insert_table_row(r)

        self._apply_filter()

    def _insert_table_row(self, r: _CatRow):
        row = self.tbl.rowCount()
        self.tbl.insertRow(row)

        # Name (editable)
        it_name = QTableWidgetItem(r.name)
        it_name.setData(Qt.UserRole, r.id)
        it_name.setFlags((it_name.flags() | Qt.ItemIsEditable) & ~Qt.ItemIsDropEnabled)
        it_name.setToolTip("Double-click to edit")
        self.tbl.setItem(row, 0, it_name)

        # Description (editable)
        it_desc = QTableWidgetItem(r.description)
        it_desc.setFlags((it_desc.flags() | Qt.ItemIsEditable) & ~Qt.ItemIsDropEnabled)
        it_desc.setToolTip("Double-click to edit")
        self.tbl.setItem(row, 1, it_desc)

        # Default rate (spinbox)
        spn = QDoubleSpinBox()
        spn.setRange(0.0, 999999.0)
        spn.setDecimals(2)
        spn.setSingleStep(1.00)
        spn.setValue(_to_dollars(r.default_price_cents))
        spn.setToolTip("Edit price")
        self.tbl.setCellWidget(row, 2, spn)

        # Active (checkbox)
        chk = QCheckBox()
        chk.setChecked(r.active)
        chk.setTristate(False)
        chk.setStyleSheet("margin-left: 8px;")
        chk.setToolTip("Toggle active")
        self.tbl.setCellWidget(row, 3, chk)

    # ---------- actions ----------
    def _add_row(self):
        self._insert_table_row(_CatRow(None, "New service", "", 0, True))

    def _duplicate_row(self):
        idxs = self.tbl.selectionModel().selectedRows()
        if not idxs:
            QMessageBox.information(self, "Duplicate", "Select a row to duplicate.")
            return
        row = idxs[0].row()
        it_name = self.tbl.item(row, 0)
        it_desc = self.tbl.item(row, 1)
        spn = self.tbl.cellWidget(row, 2)
        chk = self.tbl.cellWidget(row, 3)
        self._insert_table_row(_CatRow(
            None,
            (it_name.text() if it_name else "") + " (copy)",
            it_desc.text() if it_desc else "",
            _to_cents(spn.value()) if isinstance(spn, QDoubleSpinBox) else 0,
            bool(chk.isChecked()) if isinstance(chk, QCheckBox) else True
        ))

    def _delete_row(self):
        idxs = self.tbl.selectionModel().selectedRows()
        if not idxs:
            QMessageBox.information(self, "Delete", "Select a row to delete.")
            return
        row = idxs[0].row()
        it_name = self.tbl.item(row, 0)
        item_id = it_name.data(Qt.UserRole) if it_name else None
        if item_id:
            self._deleted_ids.add(int(item_id))
        self.tbl.removeRow(row)

    # ---------- save ----------
    def _collect_rows(self) -> List[_CatRow]:
        rows: List[_CatRow] = []
        for r in range(self.tbl.rowCount()):
            it_name = self.tbl.item(r, 0)
            it_desc = self.tbl.item(r, 1)
            spn: QDoubleSpinBox = self.tbl.cellWidget(r, 2)
            chk: QCheckBox = self.tbl.cellWidget(r, 3)

            cid = it_name.data(Qt.UserRole) if it_name else None
            nm = (it_name.text() if it_name else "").strip()
            ds = (it_desc.text() if it_desc else "").strip()
            pr = _to_cents(spn.value() if spn else 0.0)
            ac = bool(chk.isChecked()) if chk else True
            rows.append(_CatRow(id=int(cid) if cid is not None else None,
                                name=nm, description=ds,
                                default_price_cents=pr, active=ac))
        return rows

    def _save_all(self):
        rows = self._collect_rows()

        for r in rows:
            if not r.name:
                QMessageBox.warning(self, "Missing", "Every item needs a Name.")
                return

        # Deletes
        for did in list(self._deleted_ids):
            try:
                _repo_delete(self.repo, did)
            except Exception as e:
                QMessageBox.warning(self, "Delete", f"Could not delete id {did}:\n{e}")
            else:
                self._deleted_ids.discard(did)

        # Upserts
        for r in rows:
            try:
                if r.id is None:
                    _repo_create(self.repo,
                                 name=r.name,
                                 description=r.description,
                                 default_price_cents=r.default_price_cents,
                                 active=r.active)
                else:
                    _repo_update(self.repo, r.id,
                                 name=r.name,
                                 description=r.description,
                                 default_price_cents=r.default_price_cents,
                                 active=r.active)
            except Exception as e:
                QMessageBox.warning(self, "Save", f"Could not save '{r.name}':\n{e}")

        QMessageBox.information(self, "Saved", "Catalog changes saved.")
        self._load()

    # ---------- filter ----------
    def _apply_filter(self):
        needle = (self.search.text() or "").strip().lower()
        for r in range(self.tbl.rowCount()):
            name = self.tbl.item(r, 0).text().lower() if self.tbl.item(r, 0) else ""
            desc = self.tbl.item(r, 1).text().lower() if self.tbl.item(r, 1) else ""
            self.tbl.setRowHidden(r, not (needle in name or needle in desc))
