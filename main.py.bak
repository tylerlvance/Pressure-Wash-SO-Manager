# -----------------------------
# File: main.py
# -----------------------------
from __future__ import annotations

import os
import sys
import sqlite3
from typing import Optional

from PySide6.QtCore import Qt, QCoreApplication
from PySide6.QtWidgets import QApplication

from sqlalchemy import event

from db import init_engine_and_session, ensure_schema
from ui.main_window import MainWindow

APP_NAME = "Founders PW - SO Manager"


def _enable_qt_scaling():
    os.environ.setdefault("QT_ENABLE_HIGHDPI_SCALING", "0")
    os.environ.setdefault("QT_SCALE_FACTOR", "1")


def _sqlite_path_from_db_url(db_url: str) -> Optional[str]:
    """
    Extract a filesystem path from a URL like sqlite:///data/fpc.db
    Returns None for non-sqlite URLs.
    """
    if not db_url:
        return None
    lower = db_url.lower()
    if lower.startswith("sqlite:///"):
        return db_url.split("sqlite:///", 1)[1]
    if lower.startswith("sqlite://"):
        # relative or special sqlite urls; not used here
        return None
    return None


def _enable_sqlite_foreign_keys(engine):
    """
    Ensure SQLite cascade deletes run by turning on foreign_keys at connect time.
    Uses the engine you already create via init_engine_and_session.
    """
    def _fk_on(dbapi_conn, conn_record):
        cur = dbapi_conn.cursor()
        cur.execute("PRAGMA foreign_keys=ON")
        cur.close()

    # register a per-engine listener
    event.listen(engine, "connect", _fk_on, once=False)


def ensure_sqlite_columns(db_path: Optional[str]):
    """
    Lightweight self-heal for dev DBs.
    - Creates 'service_catalog' table if missing.
    - Adds price/cross-ref columns to site_services and so_services.
    - Adds any missing Invoice fields.
    Safe to call repeatedly.
    """
    if not db_path or not os.path.exists(db_path):
        return

    con = sqlite3.connect(db_path)
    cur = con.cursor()

    def table_exists(name: str) -> bool:
        cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?;", (name,))
        return cur.fetchone() is not None

    def has_col(table: str, name: str) -> bool:
        cur.execute(f"PRAGMA table_info({table})")
        return any(r[1] == name for r in cur.fetchall())

    # 1) service_catalog table
    if not table_exists("service_catalog"):
        cur.execute("""
        CREATE TABLE service_catalog (
            id INTEGER PRIMARY KEY,
            name TEXT NOT NULL UNIQUE,
            default_price_cents INTEGER NOT NULL DEFAULT 0,
            active INTEGER NOT NULL DEFAULT 1,
            created_at DATETIME
        )
        """)

    # 2) site_services: catalog_id + unit_price_cents
    if table_exists("site_services"):
        if not has_col("site_services", "catalog_id"):
            cur.execute("ALTER TABLE site_services ADD COLUMN catalog_id INTEGER")
        if not has_col("site_services", "unit_price_cents"):
            cur.execute("ALTER TABLE site_services ADD COLUMN unit_price_cents INTEGER NOT NULL DEFAULT 0")
        if not has_col("site_services", "active"):
            cur.execute("ALTER TABLE site_services ADD COLUMN active INTEGER NOT NULL DEFAULT 1")

    # 3) so_services: unit_price_cents snapshot
    if table_exists("so_services"):
        if not has_col("so_services", "unit_price_cents"):
            cur.execute("ALTER TABLE so_services ADD COLUMN unit_price_cents INTEGER NOT NULL DEFAULT 0")

    # 4) invoices: ensure all model columns exist
    invoice_cols = [
        ("invoice_no", "TEXT"),
        ("invoice_date", "DATE"),
        ("due_date", "DATE"),
        ("subtotal_cents", "INTEGER"),
        ("tax_cents", "INTEGER"),
        ("total_cents", "INTEGER"),
        ("paid", "INTEGER"),
        ("notes", "TEXT"),
        ("pdf_path", "TEXT"),
        ("created_at", "DATETIME"),
    ]
    if table_exists("invoices"):
        for col, sqltype in invoice_cols:
            if not has_col("invoices", col):
                cur.execute(f"ALTER TABLE invoices ADD COLUMN {col} {sqltype}")

    con.commit()
    con.close()


def main():
    _enable_qt_scaling()

    QCoreApplication.setApplicationName(APP_NAME)
    app = QApplication(sys.argv)

    db_url = os.getenv("FPC_DB_URL", "sqlite:///data/fpc.db")

    # Build engine + SessionLocal using your existing db.py helpers
    engine, SessionLocal = init_engine_and_session(db_url)

    # Make sure SQLite honors ON DELETE CASCADE on this engine
    _enable_sqlite_foreign_keys(engine)

    # Create any missing tables
    ensure_schema(engine)

    # Self-heal columns that the ORM expects (e.g., invoices.invoice_no)
    ensure_sqlite_columns(_sqlite_path_from_db_url(db_url))

    # Launch UI
    win = MainWindow(SessionLocal)
    win.setWindowTitle(APP_NAME)
    win.setWindowFlag(Qt.WindowMaximizeButtonHint, True)
    win.resize(1600, 900)
    win.show()

    sys.exit(app.exec())


if __name__ == "__main__":
    main()
